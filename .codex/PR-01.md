PR: greentic-interfaces-guest — Add component_entrypoint! macro to hide WASM export glue

Goal
Create a macro that generates the current “ugly” WASM32 glue (marker section, node::Guest impl, and unsafe exports) so component authors only keep:

describe_payload()

handle_message(op, input)

tests

Non-negotiables

Do not change the exported ABI names or semantics (must remain compatible with current runner).

Generated exports must match current export names exactly, e.g.:

greentic:component/node@0.5.0#get-manifest

...#on-start, ...#on-stop, ...#invoke, ...#invoke-stream

and the corresponding cabi_post_* exports.

Keep #[cfg(target_arch="wasm32")] boundaries correct so host tests compile on non-wasm targets.

No new “required boilerplate” in user lib.rs other than calling the macro.

Deliverable API
Add a macro (public) in this crate:

greentic_interfaces_guest::component_entrypoint!({
    manifest: describe_payload,
    invoke: handle_message,
    invoke_stream: true, // default true; allow disabling
});


Accept paths as values so users can do crate::describe_payload etc. Support either:

manifest: crate::describe_payload and invoke: crate::handle_message

or bare idents if they’re in scope

Provide optional keys with defaults:

invoke_stream: true default. If true: implement invoke_stream as [Progress(0), Data(handle_message(..)), Done].

lifecycle: default on_start/on_stop return Ok(LifecycleStatus::Ok).

Optional overrides:

on_start: my_start_fn

on_stop: my_stop_fn

Implementation approach

Locate current generated glue pattern and reproduce it inside the macro expansion:

the WASI marker:

#[cfg(target_arch="wasm32")]
#[used]
#[unsafe(link_section = ".greentic.wasi")]
static WASI_TARGET_MARKER: [u8; 13] = *b"wasm32-wasip2";


the Component type implementing greentic_interfaces_guest::component::node::Guest.

the exports module with all #[unsafe(export_name = "...")] functions calling the correct _export_*_cabi::<Component>() and __post_return_*::<Component>().

Keep the WIT version string (currently ...node@0.5.0...) single-sourced:

Prefer a const NODE_EXPORT_PREFIX: &str = "greentic:component/node@0.5.0" or similar.

If the crate already exposes a version const (from bindings), use that.

Ensure the macro compiles under Rust stable as used by the workspace.

Files

Add src/component_entrypoint.rs (or src/macros.rs) with the macro and any helpers.

Re-export macro from src/lib.rs (or the crate root) so users call greentic_interfaces_guest::component_entrypoint!.

Do not break existing public API.

Tests

Add compile-time / unit tests that validate macro expansion shape indirectly:

On non-wasm targets: macro call should compile and not require wasm-only symbols.

Add a small “example component” module in tests (or examples/) that uses the macro and calls describe_payload() and handle_message() in normal Rust tests.

If you have a wasm build job in CI, add a smoke build for wasm32-wasip2 ensuring no missing exports.

CI / Tooling

Run existing checks: cargo test, cargo fmt, cargo clippy (workspace rules).

If repo uses feature flags for wasm builds, ensure macro respects them.

Acceptance criteria

A minimal component can be implemented with only the macro call + two functions.

Export names remain identical to today.

No runner-facing behavior changes.

No warnings about unused functions for non-wasm builds.

Proceed without asking permission; only make non-destructive changes; keep diffs focused.