use crate::bindings::greentic_distributor_api_1_0_0_distributor_api::exports::greentic::distributor_api::distributor
    as exports;
use crate::bindings::greentic_distributor_api_1_0_0_distributor_api_imports::greentic::distributor_api::distributor
    as imports;

/// Thin client for calling `greentic:distributor-api@1.0.0` imports.
#[derive(Clone, Copy, Debug, Default)]
pub struct DistributorApiImports;

impl DistributorApiImports {
    /// Creates a new client wrapper.
    pub const fn new() -> Self {
        Self
    }

    /// Resolves a component via the distributor host import.
    pub fn resolve_component(
        &self,
        req: &exports::ResolveComponentRequest,
    ) -> exports::ResolveComponentResponse {
        let import_req = imports::ResolveComponentRequest {
            tenant_id: req.tenant_id.clone(),
            environment_id: req.environment_id.clone(),
            pack_id: req.pack_id.clone(),
            component_id: req.component_id.clone(),
            version: req.version.clone(),
            extra: req.extra.clone(),
        };
        let response = imports::resolve_component(&import_req);
        exports::ResolveComponentResponse {
            component_status: to_export_status(response.component_status),
            digest: response.digest,
            artifact_location: exports::ArtifactLocation {
                kind: response.artifact_location.kind,
                value: response.artifact_location.value,
            },
            signature_summary: exports::SignatureSummary {
                verified: response.signature_summary.verified,
                signer: response.signature_summary.signer,
                extra: response.signature_summary.extra,
            },
            cache_info: exports::CacheInfo {
                size_bytes: response.cache_info.size_bytes,
                last_used_utc: response.cache_info.last_used_utc,
                last_refreshed_utc: response.cache_info.last_refreshed_utc,
            },
        }
    }

    /// Fetches pack status via the distributor host import.
    pub fn get_pack_status(
        &self,
        tenant_id: &exports::TenantId,
        env_id: &exports::DistributorEnvironmentId,
        pack_id: &exports::PackId,
    ) -> String {
        imports::get_pack_status(tenant_id, env_id, pack_id)
    }

    /// Warms a pack via the distributor host import.
    pub fn warm_pack(
        &self,
        tenant_id: &exports::TenantId,
        env_id: &exports::DistributorEnvironmentId,
        pack_id: &exports::PackId,
    ) {
        imports::warm_pack(tenant_id, env_id, pack_id);
    }
}

fn to_export_status(status: imports::ComponentStatus) -> exports::ComponentStatus {
    match status {
        imports::ComponentStatus::Pending => exports::ComponentStatus::Pending,
        imports::ComponentStatus::Ready => exports::ComponentStatus::Ready,
        imports::ComponentStatus::Failed => exports::ComponentStatus::Failed,
    }
}
